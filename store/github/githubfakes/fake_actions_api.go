// Code generated by counterfeiter. DO NOT EDIT.
package githubfakes

import (
	"context"
	"sync"

	githuba "github.com/google/go-github/v29/github"
	"github.com/telia-oss/sidecred/store/github"
)

type FakeActionsAPI struct {
	CreateOrUpdateSecretStub        func(context.Context, string, string, *githuba.EncryptedSecret) (*githuba.Response, error)
	createOrUpdateSecretMutex       sync.RWMutex
	createOrUpdateSecretArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.EncryptedSecret
	}
	createOrUpdateSecretReturns struct {
		result1 *githuba.Response
		result2 error
	}
	createOrUpdateSecretReturnsOnCall map[int]struct {
		result1 *githuba.Response
		result2 error
	}
	DeleteSecretStub        func(context.Context, string, string, string) (*githuba.Response, error)
	deleteSecretMutex       sync.RWMutex
	deleteSecretArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	deleteSecretReturns struct {
		result1 *githuba.Response
		result2 error
	}
	deleteSecretReturnsOnCall map[int]struct {
		result1 *githuba.Response
		result2 error
	}
	GetPublicKeyStub        func(context.Context, string, string) (*githuba.PublicKey, *githuba.Response, error)
	getPublicKeyMutex       sync.RWMutex
	getPublicKeyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getPublicKeyReturns struct {
		result1 *githuba.PublicKey
		result2 *githuba.Response
		result3 error
	}
	getPublicKeyReturnsOnCall map[int]struct {
		result1 *githuba.PublicKey
		result2 *githuba.Response
		result3 error
	}
	GetSecretStub        func(context.Context, string, string, string) (*githuba.Secret, *githuba.Response, error)
	getSecretMutex       sync.RWMutex
	getSecretArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getSecretReturns struct {
		result1 *githuba.Secret
		result2 *githuba.Response
		result3 error
	}
	getSecretReturnsOnCall map[int]struct {
		result1 *githuba.Secret
		result2 *githuba.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeActionsAPI) CreateOrUpdateSecret(arg1 context.Context, arg2 string, arg3 string, arg4 *githuba.EncryptedSecret) (*githuba.Response, error) {
	fake.createOrUpdateSecretMutex.Lock()
	ret, specificReturn := fake.createOrUpdateSecretReturnsOnCall[len(fake.createOrUpdateSecretArgsForCall)]
	fake.createOrUpdateSecretArgsForCall = append(fake.createOrUpdateSecretArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *githuba.EncryptedSecret
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("CreateOrUpdateSecret", []interface{}{arg1, arg2, arg3, arg4})
	fake.createOrUpdateSecretMutex.Unlock()
	if fake.CreateOrUpdateSecretStub != nil {
		return fake.CreateOrUpdateSecretStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createOrUpdateSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeActionsAPI) CreateOrUpdateSecretCallCount() int {
	fake.createOrUpdateSecretMutex.RLock()
	defer fake.createOrUpdateSecretMutex.RUnlock()
	return len(fake.createOrUpdateSecretArgsForCall)
}

func (fake *FakeActionsAPI) CreateOrUpdateSecretCalls(stub func(context.Context, string, string, *githuba.EncryptedSecret) (*githuba.Response, error)) {
	fake.createOrUpdateSecretMutex.Lock()
	defer fake.createOrUpdateSecretMutex.Unlock()
	fake.CreateOrUpdateSecretStub = stub
}

func (fake *FakeActionsAPI) CreateOrUpdateSecretArgsForCall(i int) (context.Context, string, string, *githuba.EncryptedSecret) {
	fake.createOrUpdateSecretMutex.RLock()
	defer fake.createOrUpdateSecretMutex.RUnlock()
	argsForCall := fake.createOrUpdateSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeActionsAPI) CreateOrUpdateSecretReturns(result1 *githuba.Response, result2 error) {
	fake.createOrUpdateSecretMutex.Lock()
	defer fake.createOrUpdateSecretMutex.Unlock()
	fake.CreateOrUpdateSecretStub = nil
	fake.createOrUpdateSecretReturns = struct {
		result1 *githuba.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeActionsAPI) CreateOrUpdateSecretReturnsOnCall(i int, result1 *githuba.Response, result2 error) {
	fake.createOrUpdateSecretMutex.Lock()
	defer fake.createOrUpdateSecretMutex.Unlock()
	fake.CreateOrUpdateSecretStub = nil
	if fake.createOrUpdateSecretReturnsOnCall == nil {
		fake.createOrUpdateSecretReturnsOnCall = make(map[int]struct {
			result1 *githuba.Response
			result2 error
		})
	}
	fake.createOrUpdateSecretReturnsOnCall[i] = struct {
		result1 *githuba.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeActionsAPI) DeleteSecret(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.Response, error) {
	fake.deleteSecretMutex.Lock()
	ret, specificReturn := fake.deleteSecretReturnsOnCall[len(fake.deleteSecretArgsForCall)]
	fake.deleteSecretArgsForCall = append(fake.deleteSecretArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("DeleteSecret", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteSecretMutex.Unlock()
	if fake.DeleteSecretStub != nil {
		return fake.DeleteSecretStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteSecretReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeActionsAPI) DeleteSecretCallCount() int {
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	return len(fake.deleteSecretArgsForCall)
}

func (fake *FakeActionsAPI) DeleteSecretCalls(stub func(context.Context, string, string, string) (*githuba.Response, error)) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = stub
}

func (fake *FakeActionsAPI) DeleteSecretArgsForCall(i int) (context.Context, string, string, string) {
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	argsForCall := fake.deleteSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeActionsAPI) DeleteSecretReturns(result1 *githuba.Response, result2 error) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = nil
	fake.deleteSecretReturns = struct {
		result1 *githuba.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeActionsAPI) DeleteSecretReturnsOnCall(i int, result1 *githuba.Response, result2 error) {
	fake.deleteSecretMutex.Lock()
	defer fake.deleteSecretMutex.Unlock()
	fake.DeleteSecretStub = nil
	if fake.deleteSecretReturnsOnCall == nil {
		fake.deleteSecretReturnsOnCall = make(map[int]struct {
			result1 *githuba.Response
			result2 error
		})
	}
	fake.deleteSecretReturnsOnCall[i] = struct {
		result1 *githuba.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeActionsAPI) GetPublicKey(arg1 context.Context, arg2 string, arg3 string) (*githuba.PublicKey, *githuba.Response, error) {
	fake.getPublicKeyMutex.Lock()
	ret, specificReturn := fake.getPublicKeyReturnsOnCall[len(fake.getPublicKeyArgsForCall)]
	fake.getPublicKeyArgsForCall = append(fake.getPublicKeyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("GetPublicKey", []interface{}{arg1, arg2, arg3})
	fake.getPublicKeyMutex.Unlock()
	if fake.GetPublicKeyStub != nil {
		return fake.GetPublicKeyStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getPublicKeyReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActionsAPI) GetPublicKeyCallCount() int {
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	return len(fake.getPublicKeyArgsForCall)
}

func (fake *FakeActionsAPI) GetPublicKeyCalls(stub func(context.Context, string, string) (*githuba.PublicKey, *githuba.Response, error)) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = stub
}

func (fake *FakeActionsAPI) GetPublicKeyArgsForCall(i int) (context.Context, string, string) {
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	argsForCall := fake.getPublicKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeActionsAPI) GetPublicKeyReturns(result1 *githuba.PublicKey, result2 *githuba.Response, result3 error) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	fake.getPublicKeyReturns = struct {
		result1 *githuba.PublicKey
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActionsAPI) GetPublicKeyReturnsOnCall(i int, result1 *githuba.PublicKey, result2 *githuba.Response, result3 error) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	if fake.getPublicKeyReturnsOnCall == nil {
		fake.getPublicKeyReturnsOnCall = make(map[int]struct {
			result1 *githuba.PublicKey
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getPublicKeyReturnsOnCall[i] = struct {
		result1 *githuba.PublicKey
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActionsAPI) GetSecret(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.Secret, *githuba.Response, error) {
	fake.getSecretMutex.Lock()
	ret, specificReturn := fake.getSecretReturnsOnCall[len(fake.getSecretArgsForCall)]
	fake.getSecretArgsForCall = append(fake.getSecretArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("GetSecret", []interface{}{arg1, arg2, arg3, arg4})
	fake.getSecretMutex.Unlock()
	if fake.GetSecretStub != nil {
		return fake.GetSecretStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getSecretReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeActionsAPI) GetSecretCallCount() int {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	return len(fake.getSecretArgsForCall)
}

func (fake *FakeActionsAPI) GetSecretCalls(stub func(context.Context, string, string, string) (*githuba.Secret, *githuba.Response, error)) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = stub
}

func (fake *FakeActionsAPI) GetSecretArgsForCall(i int) (context.Context, string, string, string) {
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	argsForCall := fake.getSecretArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeActionsAPI) GetSecretReturns(result1 *githuba.Secret, result2 *githuba.Response, result3 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	fake.getSecretReturns = struct {
		result1 *githuba.Secret
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActionsAPI) GetSecretReturnsOnCall(i int, result1 *githuba.Secret, result2 *githuba.Response, result3 error) {
	fake.getSecretMutex.Lock()
	defer fake.getSecretMutex.Unlock()
	fake.GetSecretStub = nil
	if fake.getSecretReturnsOnCall == nil {
		fake.getSecretReturnsOnCall = make(map[int]struct {
			result1 *githuba.Secret
			result2 *githuba.Response
			result3 error
		})
	}
	fake.getSecretReturnsOnCall[i] = struct {
		result1 *githuba.Secret
		result2 *githuba.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActionsAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createOrUpdateSecretMutex.RLock()
	defer fake.createOrUpdateSecretMutex.RUnlock()
	fake.deleteSecretMutex.RLock()
	defer fake.deleteSecretMutex.RUnlock()
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	fake.getSecretMutex.RLock()
	defer fake.getSecretMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeActionsAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ github.ActionsAPI = new(FakeActionsAPI)
